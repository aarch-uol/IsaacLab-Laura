"""

    This prompt applies to IsaacLab-based simulation code. 
    Your task is to generate a single, valid Python file with no syntax errors. 
    The output should be minimal, correct, and closely match the structure and content of the given file.
    The content of the output file should only differ by the objects spawned from the given file.
    This file defines a configuration class for part of a simulation environment.

    ### Task description

    User description: {user_input}
    Think about which laboratory equipment from the original file would be used to complete the task in the user description.
    Use this equipment for **objects required**.

    ### Imports

    - Extract **only and all of the 12 lines of import statements** that are in the **given file**.
    - Add them **once at the very top** of your output script.
    - Every import must start with `isaaclab` or `glassware_files`.
    - **Do not repeat or invent any import**.
    - **Do not add extra imports**, even if they seem necessary.
    - **`PourEnvCfg` is in `lab_env_cfg` file in `stack` folder**.
    - If `pour` in user description, then change import StackEnvCfg to PourEnvCfg.

    ### DoneTerm Definitions

    - Write **exactly** 4 DoneTerms for:
        - Two terms for object dropping as shown in the given file, one for object1 and one for object2.
        - Must include one of (Success Term): mdp.objects_stacked function and mdp.object_reached_goal.
        - A time out term, the DoneTerm includes: func=mdp.time_out, time_out=True.
    Strictly Ensure that there are 4 DoneTerms under TerminationsCfg.

    Success Condition Selection Rules:
        - For objects_stacked (used for any tasks involving stacking object1 onto object2):
            - Use objects_stacked **only** if object_stacked is appropriate for the final subtask.
            - Requires no params
        - For object_reached_goal (used if stacking isn't applicable for final subtask):
            - Use object_reached_goal **only** if object_near_goal is appropriate for the final subtask.
            - Requires no params

    ### ObsGroup/ObsTerm Definitions

    - Create an ObservationsCfg Class.
    - Within the ObservationsCfg Class, create two Classes: PolicyCfg and SubtasksCfg, inheriting from ObsGroup.
    - At the end of ObservationsCfg Class create an instance for: PolicyCfg and SubtasksCfg **each** with `enable_corruption`, `concatenate_terms` which are both `False`.
    - Inside the PolicyCfg, define ObsTerms for only the following **9** observation functions and no params: `last_action`, `joint_pos_rel`, `joint_vel_rel`, `object_obs`, 
    `object_positions_in_world_frame`, `object_orientations_in_world_frame`, `ee_frame_pos`, `ee_frame_quat`, `gripper_pos`.

    - In SubtasksCfg, create a logical sequence of subtasks using ObsTerm for a robot to complete the user-defined task.
    - The following func= values are available for the ObsTerm subtasks: 
        - Must include: reach_object, object_grasped, is_object_lifted, object_reached_midgoal, reach_object2
        - Might include: pour_object, reorient_object (follow pour_object)
        - Must include one of (Termination Function): object_stacked, object_near_goal.
    - Use func=reach_object2 instead of func=reach_object if a second reach is needed.

    - The function `object_grasped` should have three params with the names: `ee_frame_cfg`, `robot_cfg` and `object_cfg`.
    - The function `reach_object`/`reach_object2` should have three params with the names: `ee_frame_cfg`, `object_cfg` and `threshold`.
    - The function `object_reached_midgoal` should have two params with the names `threshold` and `command_name` : "object_pose".
    - The function `is_object_lifted` should have two params with the names `threshold` and `object_cfg`.
    - The functions `pour_object`/`reorient_object` should have two params with the names `angle_threshold` = 45/175 (respectively) and `ee_frame_cfg`.

    Termination Function Rules:
        - For object_stacked (used for tasks involving stacking object1 onto object2):
            - Use object_stacked **only** if appropriate for the final subtask.
            - Requires params:
                - upper_object_cfg → SceneEntity "object1"
                - lower_object_cfg → SceneEntity "object2"
                - robot_cfg → SceneEntity "robot"
        - For object_near_goal (used if stacking isn't applicable for final subtask):
            - Requires:
                - threshold
                - robot_cfg
                - object_cfg → SceneEntity "object1"
        - The most appropriate termination function is the **last subtask** of the user-defined task.

    General Parameter Mapping Rules:
    - Use SceneEntity "object1" if the subtask name includes "object".
    - Use SceneEntity "object2" if the subtask name includes "object2".
    - Use SceneEntity "robot" only for object_grasped, object_stacked and object_near_goal.
    - Use SceneEntity "ee_frame" for any ee_frame_cfg parameter.
    - The threshold value should be between 0.05 and 0.1.

    - All of the functions for the ObsTerms and are from the folder mdp.
    - At the end of ObservationsCfg Class, create instance

    ### FrankaCubeStack Class Definitions

    Use the `@configclass` decorator for any Classes, as in the given file, including `FrankaCubeStackEnvCfg(StackEnvCfg)`

    Change the inheritance of `FrankaCubeStackEnvCfg` only if the task involves `pour` in the task description:
        - Change `StackEnvCfg` to `PourEnvCfg`.
    If `pour` is not in the task description then keep `StackEnvCfg`.

    In `FrankaCubeStackEnvCfg`:
        - Include a method called `__post_init__()` that contains `super().__post_init__()`.
        - Create an instance using self.observations = ObservationsCfg() with comment # Set Observations.
        - **Do not change** the semantic tags for the plane or table.
        - Include **only and exactly all** of the `actions` and `commands` from the given file.
        - Use the same robot setup code from the provided file (Franka, with the correct semantic tags).
    Strictly ensure ObservationsCfg() instance is created.

    ### Task Specific Objects

    - Use **only** objects defined in the original file — do **not invent new ones**.
    - Instantiate only the **Franka robot** and the **objects required** to complete the user-defined task.
    - **Do not use all of the objects from the original file**.
    - The **hot plate** object in the USD file refers to a **magnetic stir plate**.
    - The “main object” is the one moved within the task. You must decide which one that is based on the task description.
    - This main object will be a piece of glassware.

    In the output file:
        ***CRITICAL NAMING RULE — FOLLOW EXACTLY*** 
        For the task's **main object**, use this naming style:

        DO NOT USE THIS (placeholder style — REMOVE IT):  
        ```python
        self.scene.<glassware> = glassware.<glassware>
        ```
        INSTEAD, RENAME LIKE THIS (example if object1):
        ```python
        self.scene.object1 = glassware.<glassware>
        ```
        Replace <glassware> with the actual object name from the task, and assign it to a standardized scene name like object1, object2, etc.
        Do not include any placeholder code like <glassware> in your final output.
    - Replace the lab equipment that is completing the task or is the target to follow the naming convention for object2 similar to above.
    - If there are two names for an instance, keep only the name involving object1.
    - Add a side comment indicating which objects were chosen as the main object and object2 for the task.

    ### Robot and Frame Transformations

    - Write the `Frame Transformations` from the given file **exactly** at the end of the code.
    - Do not modify any of the values or change the structure from that block of code.
    - Do not invent, change, or omit any fields or values.
    - From that block, one FrameTransformerCfg, with the name `self.scene.ee_frame`, should be created with FrameCfgs for:
        1. panda_hand
        2. panda_leftfinger
        3. panda_rightfinger
    - With the names (respectively):
        1. end_effector
        2. tool_leftfinger
        3. tool_rightfinger
    - For each FrameCfg use **the same** values from the original code for:
        - prim_path
        - name
        - offset=OffsetCfg(pos=...)
    - The `FrameTransformerCfg` uses the  same `prim_path`, `visualizer_cfg`, `debug_vis` and `target_frames` values as the given file.
    - Keep OffsetCfg property `pos=` for the `panda_hand`, `panda_leftfinger`, and `panda_rightfinger` the same as in the given file.

    Given/Original file to reference: {file_content}
    ```plaintext
    Reminder: ALL object assignments must use the format `self.scene.object1 = ...` and **must not include placeholder code like `<glassware>`**.
    Reminder: Do not complete use objects_stacked if both objects are **glassware**.


    """