    This file defines a configuration class for part of a simulation environment.
    I am working with Isaaclab.
    I want you to output a code script.
    Write out the imports that are within the given file only once, at the **vert top** of your script.
    All of the import statements should start with "isaaclab".
    Do not repeat any imports elsewhere in the script.
    Do not invent, modify, or add new imports.

    Write of the first three event configurations using EventTerm() from the given file in the output file. 
    Within the EventTerm(), write the same params in the output file as in the given file.

    Your output script should include the robot and the two objects: a cube and a hot plate.
    Change the `name` of the cube, for example the output for a cube could be self.scene.object1 = glassware.cube rather than self.scene.cube = glassware.cube
    Use @configclass for FrankaCubeStackEnvCfg() and EventsCfg() as in the given file.
    Define these objects in the class FrankaCubeStackEnvCfg(StackEnvCfg), and make sure the method super().__post_init__() is included in __post_init__().
    Write the method to Set Franka as the robot from the given file in the output file including the same semantic tags.
    Do not change the semantics for the plane and table in the FrankaCubeStackEnvCfg class.
    Other than the code relating to spawning objects, within the FrankaCubeStackEnvCfg class, all the code should be the same from the given file.

    Set the actions for the franka robot in the output file, the same as in the given file.
    Write the exact same code for the end effector frame transformations from in the output file as is in the given file.

    Specifically, ensure that:
    - The `FrameTransformerCfg` uses the  same `prim_path`, `visualizer_cfg`, and `debug_vis` settings.
    - The `target_frames` list contains `FrameTransformerCfg.FrameCfg` entries for all of: `panda_hand`, `panda_leftfinger`, and `panda_rightfinger`.
    - All field values (e.g., `prim_path`, `name`, `offset`) must exactly match the original file. Do not modify or invent new values.
    - Keep OffsetCfg property pos for the `panda_hand`, `panda_leftfinger`, and `panda_rightfinger` the same as in the given file.

    Strictly ensure:
    - I need a **single Python file** that:
    - 1. **Imports only once** from `glassware_files` (no repeated imports).
    - 2. **Spawns only two objects**: a cube (renamed to `object1`) and a hot plate.
    - 3. **Includes three frame transformations**:
        - `end_effector_frame()`
        - `gripper_frame()`
        - `gripper_joint_frame()`
    - 4. **No syntax errors** — all functions and object definitions must be valid.
    - 5. **No extra code** — only the minimal necessary to fulfill the above.

### MIGHT NEED IF PROMPT DOESN'T

    Strictly ensure:
    - I need a **single Python file** that:
    - 1. **Imports only once** from `glassware_files` (no repeated imports).
    - 2. **Spawn object needed for task only**
    - 3. **Include three `FrameTransformerCfg`, each with a FrameCfg entries in the target_frames list**
    - 4. **No syntax errors** — all functions and object definitions must be valid.
    - 5. **No extra code** — only the minimal necessary to fulfill the above.


    In `FrankaCubeStackEnvCfg`:
        - Include a method called `__post_init__()` that contains `super().__post_init__()`.
        - **Do not change** the semantic tags for the plane or table.
        - All code in this Class must exactly match the given file — except for object spawning.
        - Include all of the actions and commands from the given file.


    - **Do not change** any of the code for the FrameTransformerCfg from the given file.
    - Add one FrameTransformerCfg with the following three FrameCfg entries in this exact order within target_frames:
        1. panda_hand
        2. panda_leftfinger
        3. panda_rightfinger
    - For each FrameCfg:
        - Use the same prim_path, name, and OffsetCfg(pos=...) values as the original file.
        - Do not change, remove or invent any values or fields.

    - **Do not modify** any of the code for the `Frame Transformations` from the given file in the output file.
    - There should be one FrameTransformerCfg with the following three FrameCfg entries in this exact order within target_frames:
        1. panda_hand
        2. panda_leftfinger
        3. panda_rightfinger
    - For each FrameCfg:
        - Use the same `prim_path`, `name`, and `OffsetCfg(pos=...)` values as the original file.
        - Do not change, remove or invent any values or fields.

    - From that block, extract and recreate a FrameTransformerCfg which contains the following three FrameCfg entries, and in this exact order within target_frames:
        1. panda_hand
        2. panda_leftfinger
        3. panda_rightfinger
    - For each FrameCfg:
        - Use the exact values from the original code:
            - prim_path
            - name
            - offset=OffsetCfg(pos=...)
    
    - Locate the Frame Transformations block of code (the last 26 lines of code) in the original file.
    - Copy these 26 lines of code **exactly** at the end of your written code.
    - Do not modify any of the values or structure from that block.
    - Do not invent, change, or omit any fields or values.
    - From that block, a FrameTransformerCfg should be created for:
        1. panda_hand
        2. panda_leftfinger
        3. panda_rightfinger
    - With the names (respectively):
        1. end_effector
        2. tool_leftfinger
        3. tool_rightfinger
        - Use the same prim_path, name, and OffsetCfg(pos=...) values as the original file.



    - In SubtasksCfg, create subtasks for the task in the user description.
    - The subtasks should link and flow together to be checkpoints to complete the task description.
    - The possible functions (func=) for the ObsTerm subtasks are: reach_object, object_grasped, is_object_lifted, object_reached_midgoal, reach_object2, object_stacked,
    pour_object, reorient_object, object_reached_goal.
    - Only use func=reach_object once, if a second one is needed then use func=reach_object2.
    - The subtask ObsTerms each have `params`, decide which params are needed for each subtask. 

###
    - object_stacked and object_reached_goal are termination functions, the most appropriate to the task description should be used for the final subtask.
    - func=object_stacked has params of "upper_object_cfg" and "lower_object_cfg" as the names for SceneEntity of "object1" and "object2" respectively as well as "robot_cfg".
    - The **only** other names for the parameters are "robot_cfg", "ee_frame_cfg", "object_cfg", "object2_cfg", "angle_threshold" and "threshold".
    - For subtasks of reaching, grasping and lifting an object (not including object_reached_midgoal or object_reached_goal): include the SceneEntityCfg 
    of "object1" if an "object" is in the subtask name, "object2" if "object2" is in the subtask name, for the parameter value.
    - The parameter value SceneEntityCfg of "robot" is only used for the object_grasped and object_stacked function.
    - The parameter name "ee_frame" should have the value SceneEntity "ee_frame"
    - If object_reached_midgoal or object_reached_goal is used, one of the parameters "command_name": "object_pose".
    - For pour and reorient object functions, "angle_threshold" is a parameter of 45 and 175 respectively.
    - For functions: the "threshold" parameter should be between 0.05 and 0.1.
###

    - The function `object_grasped` should have three params with the names: `ee_frame_cfg`, `robot_cfg` and `object_cfg`.
    - The function `reach_object`/`reach_object2` should have three params with the names: `ee_frame_cfg`, `object_cfg` and `threshold`.
    - The function `object_reached_goal`/`object_reached_midgoal` should have two params with the names `threshold` and `command_name`.
    - The function `is_object_lifted` should have two params with the names `threshold` and `object_cfg`.
    - The functions `pour_object` and `reorient_object` should have two params with the names `angle_threshold` and `ee_frame_cfg`.

    Look at lines 63 to 76 of: {file_content}
    Look at this file for reference in the rest of this prompt: {file_content}

    - Rename the chosen main object to follow the self.scene.object1 naming convention as shown above.

    Strictly Ensure that there are 4 DoneTerms under TerminationsCfg.

    - For object1 also include an object dropping term for onto the table rather than below the table which is at 0.005 height.

    - Instantiate **only** the **Franka robot** and **objects required** to complete the user-defined task.

The most appropriate termination function should be the last subtask of the user-defined task.

    - In SubtasksCfg, create ObsTerm subtasks that logically sequence together to complete the task in the task description.


    - Write **exactly** 4 DoneTerms for:
        - Two terms for object dropping as shown in the given file, one for object1 and one for object2.
        - Must include one of (Success Term): mdp.objects_stacked function or mdp.object_reached_goal function.
        - This success term is based on the last task in the user description.
        - A time out term, the DoneTerm includes: func=mdp.time_out, time_out=True.
    Strictly Ensure that there are 4 DoneTerms under TerminationsCfg.

    Success Condition Selection Rules:
        - For `objects_stacked` (used for any tasks involving stacking object1 onto object2):
            - Use `objects_stacked` **only** if object_stacked is appropriate for the final subtask.
            - If there is one task: `objects_stacked` only params= `"object_2_cfg": SceneEntityCfg object2`.
            - If there is two tasks: `objects_stacked` only params= `"object_2_cfg": SceneEntityCfg object3`.
        - For `object_reached_goal` (used if stacking isn't applicable for final subtask):
            - Use `object_reached_goal` **only** if object_near_goal is appropriate for the final subtask.
            - Requires no params


    Generate **exactly** four DoneTerms for the TerminationsCfg section. The four required terms are:
        A term for dropping object1.
        A term for dropping object2.
        A success term based on the last user-defined task.
        A timeout term.
    Detailed Rules for Success and Timeout Terms:
        **Success Term**: You **must** select and use **only one* of these functions for the success term:
            mdp.objects_stacked: Use this if the final subtask is to place object1 onto apparatus.
                If there is **one task**, the parameters must be "object_2_cfg": SceneEntityCfg object2.
                If there are **two tasks**, the parameters must be "object_2_cfg": SceneEntityCfg object3.
            mdp.object_reached_goal: Use this if the final subtask is for an object to reach a specific goal location. This function requires no parameters.
        **Timeout Term**: The DoneTerm for a timeout must always be defined as:
        func=mdp.time_out, time_out=True



    ### Imports

    - **`PourEnvCfg` is in `lab_env_cfg` file in `stack` folder**.
    - If `pour` in user description, then change import StackEnvCfg to PourEnvCfg.


    Change the inheritance of `FrankaCubeStackEnvCfg(StackEnvCfg)` only IF the task involves `pour` in the task description:
        - Change `StackEnvCfg` to `PourEnvCfg`.
    If `pour` is not in the task description then keep `StackEnvCfg`.


        - Use SceneEntityCfg("object1") for any subtask with "object" in the name.
        - For a **Single Task**:
            - Use SceneEntityCfg("object2") for `"object2"` subtasks.
        - **For Two Tasks**:
            - **In the subtask sequence for Task 1**: use SceneEntityCfg("object2") for `"object2"` subtasks.
            - **In the subtask sequence for Task 2**: use SceneEntityCfg("object3") for `"object2"` subtasks.



    - Create **exactly** 4 DoneTerms for:
        - Two terms for object dropping as shown in the given file, one for object1 and one for object2.
        - Must include one of (Success Term): mdp.objects_stacked function or mdp.object_reached_goal function.
        - A time out term, the DoneTerm includes: func=mdp.time_out, time_out=True.
    Strictly Ensure that there are 4 DoneTerms under TerminationsCfg.

    Success Condition Selection Rules:
        - For `objects_stacked` (used for any tasks involving stacking object1 onto object2):
            - Use `objects_stacked` **only** if object_stacked is appropriate for the final subtask.
            - If there is one task: `objects_stacked` only params= `"object_2_cfg": SceneEntityCfg object2`.
            - If there is two tasks: `objects_stacked` only params= `"object_2_cfg": SceneEntityCfg object3`.
        - For `object_reached_goal` (used if stacking isn't applicable for final subtask):
            - Use `object_reached_goal` **only** if object_near_goal is appropriate for the final subtask.
            - Requires no params


### When used the only difference was that midgoal for heat/weigh missing and policy/subtask postinit working - for below
### Termination for both success = reach goal and subtask = stacked 
### Objects all correct for both
### I noticed policies arent changing to use 2 versions - this may be ue to LLM prompt being too long, too much for LLM to digest
    Subtask Functions & Parameters
    Define subtasks using the func= parameter, following these rules.
    **Subtask Types**
        **Core Subtasks**: reach_object, object_grasped, is_object_lifted, object_reached_midgoal, reach_object2.
        **Optional Pouring Subtasks**: For pouring tasks, use pouring_solution followed by reorient_object.
        **Final Subtasks**: The final subtask for any sequence must be one of the following: object_stacked or object_near_goal.
    **Function Parameters**
        The subtasks reach_object, reach_object2, object_grasped, and is_object_lifted require the object_cfg parameter.
    **Termination Function Rules**
        object_stacked: Use this for tasks where object1 is placed on another object.
        Requires two parameters:
            - upper_object_cfg: Always SceneEntityCfg("object1")
            - lower_object_cfg: SceneEntityCfg("object2") for a single task, or SceneEntityCfg("object3") for two tasks.
        object_near_goal: Use this when object_stacked doesn't apply.
        Requires object_cfg: Always SceneEntityCfg("object1").
    Note: reach_object2 is used for a second reach in a task. The termination function is always the last subtask in a sequence.



    Create **exactly** 4 DoneTerms for  the TerminationsCfg class, following these specific rules:
        - Two terms for object dropping as shown in the given file, one for object1 and one for object2.
        - One of (Success Term):
            If stacking or placing an object is the final subtask, use DoneTerm(func=mdp.objects_stacked).
                - For one task, include params: "object_2_cfg": SceneEntityCfg("object2").
                - For two tasks, include params: "object_2_cfg": SceneEntityCfg("object3").
            Otherwise, use DoneTerm(func=mdp.object_reached_goal). This requires no parameters.
        - A time out term, the DoneTerm includes: func=mdp.time_out, time_out=True.


If task involved placing object1 onto apparatus for the final subtask, use DoneTerm(func=mdp.objects_stacked).

- Only `reach_object` / `reach_object2` / `object_grasped` / `is_object_lifted` requires: `object_cfg`.
delete comment line at top


    - If there are two names for an instance, keep only the name involving object1.
    - Each instantiated object must have a side comment explaining:
        - Whether it is the main object.
        - Which task it is used in.

    DO NOT:
    - Do not use object2 for both tasks.
    - Do not use object3 if there's only one task.
    - Do not name the target equipment anything other than object2 or object3 depending on task order.

    REMEMBER:
    - object1 = main object (the glassware being moved) — always the same, used for all tasks.
    - object2, object3 = equipment the main object interacts with (assigned by task number).
    - Count your instantiated objects. There must be no more than 3 total.




    User description: {user_input}
    Think about which laboratory equipment from the original file would be used to complete the task in the user description.
    Look at the user description and decide how many tasks have been described.
    Add a comment: name the first task 'Task 1' and the second (if applicable) 'Task 2'.


    Create **exactly** 4 DoneTerms for  the TerminationsCfg class, following these specific rules:
        - Two terms for object dropping as shown in the given file, one for object1 and one for object2.
        - One of (Success Term):
            Final Subtask	DoneTerm Function	Required Parameters
            Stacking or placing object1	mdp.objects_stacked	object_2_cfg = SceneEntityCfg("object3") for two tasks and SceneEntityCfg("object2") for one task.
            All other tasks	mdp.object_reached_goal	None
        - A time out term, the DoneTerm includes: func=mdp.time_out, time_out=True.

    - One of (Success Term):
    - Final Subtask: Stacking or placing object1 on apparatus (object2/object3) **(e.g., placing a beaker on a hot plate to heat)**.
        - DoneTerm Function: mdp.objects_stacked
        - Required Parameters: "lower_object_cfg": SceneEntityCfg("apparatus")
    - All other tasks:
        - DoneTerm Function: mdp.object_reached_goal
        - Required Parameters: None


    Condition	Functions to Use (for func=)
    If only one task	last_action, joint_pos_rel, joint_vel_rel, object_obs, object_positions_in_world_frame, object_orientations_in_world_frame, ee_frame_pos, ee_frame_quat, gripper_pos
    If two tasks	last_action, joint_pos_rel, joint_vel_rel, object_obs2, object_positions_in_world_frame2, object_orientations_in_world_frame2, ee_frame_pos, ee_frame_quat, gripper_pos
